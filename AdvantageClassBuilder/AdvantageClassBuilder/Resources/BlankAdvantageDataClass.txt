' $---$
' --- $Database$.$SchemaName$$ClassShort$ ---
' $---$

' --- This file is automatically generated. Please don't change! ---

Imports System.Text
Imports Arena_DataConn
Imports System.Data.SqlClient
Imports Arena_Utilities.StringUtils

Public Class $ClassName$

    ' --- This differentiates local objects from web service objects ---
    ' --- Assume all objects are Local at this point. ---
    Protected IsLocal As Boolean = True

    ' --- Turn this on when filling fields from the database ---
    Protected IsFillingFields As Boolean = False

#Region " Constants "

    Private Shared ReadOnly ObjName As String = System.Reflection.MethodBase.GetCurrentMethod().ReflectedType.FullName

    Private Shared _SQLTableName As String = "$SchemaFull$[$ClassShort$]"
    Private Shared _BaseQuery As String = $BaseQuery$
    Private Shared _FirstConj As String = $FirstConj$
    Private Shared _DeleteQuery As String = $DeleteQuery$

    Public Shared ReadOnly Property SQLTableName() As String
        Get
            FixSQLTablename()
            Return _SQLTableName
        End Get
    End Property
    Partial Private Shared Sub FixSQLTablename()
    End Sub

    Public Shared ReadOnly Property BaseQuery() As String
        Get
            FixBaseQuery()
            Return _BaseQuery
        End Get
    End Property
    Partial Private Shared Sub FixBaseQuery()
    End Sub

    Public Shared ReadOnly Property FirstConj() As String
        Get
            FixFirstConj()
            Return _FirstConj
        End Get
    End Property
    Partial Private Shared Sub FixFirstConj()
    End Sub

    Public Shared ReadOnly Property DeleteQuery() As String
        Get
            FixDeleteQuery()
            Return _DeleteQuery
        End Get
    End Property
    Partial Private Shared Sub FixDeleteQuery()
    End Sub

#End Region

#Region " Property IsChanged (Boolean, Internal) "

    Private _IsChanged_Default As Boolean = False
    Private _IsChanged As Boolean = _IsChanged_Default

    Public Property IsChanged() As Boolean
        Get
            Return _IsChanged
        End Get
        Set(ByVal value As Boolean)
            If value Then
                _IsChanged = True
            Else
                _IsChanged = False
            End If
        End Set
    End Property

#End Region

#Region " Property IsNew (Boolean, Internal) "

    Private _IsNew_Default As Boolean = True
    Private _IsNew As Boolean = _IsNew_Default

    Public Property IsNew() As Boolean
        Get
            Return _IsNew
        End Get
        Set(ByVal value As Boolean)
            _IsNew = value
        End Set
    End Property

#End Region

#Region " Property IsDeleted (Boolean, Internal) "

    Private _IsDeleted_Default As Boolean = False
    Private _IsDeleted As Boolean = _IsDeleted_Default

    Public Property IsDeleted() As Boolean
        Get
            Return _IsDeleted
        End Get
        Set(ByVal value As Boolean)
            _IsDeleted = value
        End Set
    End Property

#End Region

$Properties$

#Region " Get Routines "

    Public Shared Function GetBy$Identity$(ByVal $Identity$ As Integer) As $ClassName$
        Return $ClassName$.GetBySQL(BaseQuery + FirstConj + " [$Identity$] = " + $Identity$.ToString)
    End Function

    Public Shared Function GetBySQL(ByVal SQLClause As String) As $ClassName$
        Dim Result As $ClassName$ = Nothing
        Dim dc As New Arena_DataConn.DataConnection
        Try
            Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
                cn$ConnName$.Open()
                Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        Result = New $ClassName$
                        $ClassName$.FillFields(Result, dr)
                    End If
                    dr.Close()
                End Using
            End Using
        Catch ex As Exception
            Throw ' re-throw the exception
        End Try
        Return Result
    End Function

    Public Shared Function GetAll() As List(Of $ClassName$)
        Return $ClassName$.GetAllBySQL(BaseQuery + " ORDER BY [$Identity$]")
    End Function

    Public Shared Function GetAllBySQL(ByVal SQLClause As String) As List(Of $ClassName$)
        Dim Temp$ClassName$ As $ClassName$
        Dim Result As New List(Of $ClassName$)
        Dim dc As New Arena_DataConn.DataConnection
        Try
            Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
                cn$ConnName$.Open()
                Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleResult)
                    Do While dr.Read
                        Temp$ClassName$ = New $ClassName$
                        $ClassName$.FillFields(Temp$ClassName$, dr)
                        Result.Add(Temp$ClassName$)
                    Loop
                    dr.Close()
                End Using
            End Using
        Catch ex As Exception
            Throw ' re-throw the exception
        End Try
        Return Result
    End Function

#End Region

#Region " Internal Routines "

    Friend Overloads Shared Sub FillFields(ByVal Obj As $ClassName$, ByVal dr As SqlDataReader)
        If Obj Is Nothing Then Exit Sub
        If dr Is Nothing Then Exit Sub
        ' --- Prevent IsChanged = True while filling fields ---
        Obj.IsFillingFields = True
$FillFields$
        ' --- Internal Flags ---
        Obj.IsNew = False
        Obj.IsDeleted = False
        Obj.IsChanged = False
        ' --- only local objects use FillFields to populate properties ---
        Obj.IsLocal = True
        ' --- Done filling fields ---
        Obj.IsFillingFields = False
    End Sub

    Protected Overloads Shared Sub Validate(ByVal Obj As $ClassName$)
        If Obj Is Nothing Then Exit Sub
$ValidateList$
    End Sub

    Protected Overloads Sub FieldList(ByVal sb As StringBuilder)
        ' --- used in the list of fields in an INSERT INTO command ---
        With sb
$FieldList$
        End With
    End Sub

    Protected Overloads Sub ValueList(ByVal sb As StringBuilder)
        ' --- used in the list of values in an INSERT INTO command ---
        With sb
$ValueList$
        End With
    End Sub

    Protected Overloads Sub UpdateList(ByVal sb As StringBuilder)
        ' --- used in the SET section of an UPDATE command ---
        With sb
$UpdateList$
        End With
    End Sub

#End Region

#Region " Save Routine "

    Public Sub Save()
        Dim dc As New DataConnection
        $ClassName$.Save(Me, dc)
    End Sub

    Public Sub Save(ByVal dc As DataConnection)
        $ClassName$.Save(Me, dc)
    End Sub

    Public Shared Sub Save(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
        Static FuncName As String = ObjName + "." + System.Reflection.MethodBase.GetCurrentMethod().Name
        Dim sb As New StringBuilder
        Dim cn$ConnName$ As SqlConnection
        ' $---1---$
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- delete record ---
        If Obj.IsDeleted Then
            $ClassName$.Delete(Obj, dc)
            Exit Sub
        End If
        Try
            ' --- fix record before saving if necessary ---
            FixRecordPreSave(Obj, dc)
            ' --- validate before saving ---
            $ClassName$.Validate(Obj)
            ValidateRecordLevel(Obj)
            ' --- add new record ---
            If Obj.IsNew OrElse Obj.$Identity$.GetValueOrDefault <= 0 Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("INSERT INTO ")
                        .Append(SQLTableName)
                        .Append(" (")
                        Obj.FieldList(sb)
                        .Append(") VALUES (")
                        Obj.ValueList(sb)
                        .Append(") ; ")
                        ' --- Return the new record ---
                        .Append(BaseQuery)
                        .Append(FirstConj)
                        .Append(" [$Identity$] = SCOPE_IDENTITY()")
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        $ClassName$.FillFields(Obj, dr)
                    Else
                        dc.Rollback()
                        Throw New SystemException("Record unexpectedly missing.")
                    End If
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- update changed record ---
            If Obj.IsChanged Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("UPDATE ")
                        .Append(SQLTableName)
                        .Append(" SET ")
                        Obj.UpdateList(sb)
                        .Append(" WHERE [$Identity$] = ") : .Append(Obj.$Identity$.Value.ToString)
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim RowsChanged As Integer = cmd.ExecuteNonQuery
                    If RowsChanged < 1 Then
                        dc.Rollback()
                        Throw New SystemException("Record unexpectedly missing or changed.")
                    End If
                    ' --- reload record to get updated values (such as RowVersion) ---
                    cmd.CommandText = BaseQuery + FirstConj + " [$Identity$] = " + Obj.$Identity$.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        $ClassName$.FillFields(Obj, dr)
                    Else
                        dc.Rollback()
                        Throw New SystemException("Record unexpectedly missing.")
                    End If
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- fix record after saving if necessary ---
            FixRecordPostSave(Obj, dc)
        Catch ex As Exception
            dc.Rollback()
            Throw New SystemException(FuncName + vbCrLf + "Error saving record." + vbCrLf + ex.Message)
        End Try
    End Sub

    Partial Private Shared Sub FixRecordPreSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ValidateRecordLevel(ByVal Obj As $ClassName$)
    End Sub
    Partial Private Shared Sub FixRecordPostSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

#Region " Delete Routine "

    Public Sub Delete()
        Dim dc As New DataConnection
        $ClassName$.Delete(Me, dc)
    End Sub

    Public Sub Delete(ByVal dc As DataConnection)
        $ClassName$.Delete(Me, dc)
    End Sub

    Public Shared Sub Delete(ByRef Obj As $ClassName$, ByVal dc As DataConnection)
        Dim cn$ConnName$ As SqlConnection
        ' $---1---$
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- Validate if record may be safely deleted ---
        ValidatePreDelete(Obj, dc)
        ' --- Release any resources before deleting if necessary ---
        ReleaseResourcesPreDelete(Obj, dc)
        ' --- Delete current record ---
        If Obj.$Identity$.HasValue AndAlso Obj.$Identity$.Value > 0 Then
            Try
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    cmd.CommandText = DeleteQuery + " WHERE [$Identity$] = " + Obj.$Identity$.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    cmd.ExecuteNonQuery()
                End Using
                dc.CloseConnection(cn$ConnName$)
            Catch ex As Exception
                dc.Rollback()
                Throw ' re-throw the exception
            End Try
        End If
        ' --- Release any resources after deleting if necessary ---
        ReleaseResourcesPostDelete(Obj, dc)
        ' --- Done ---
        Obj.$Identity$ = Nothing
        Obj.IsDeleted = True
        Obj.IsNew = False
        Obj.IsChanged = False
    End Sub

    Partial Private Shared Sub ValidatePreDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ReleaseResourcesPreDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ReleaseResourcesPostDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

End Class

Public Class $ClassName$_Reader

    Implements IDisposable

#Region " Reader Routines "

    Private dc As Arena_DataConn.DataConnection
    Private cn$ConnName$ As SqlClient.SqlConnection
    Private cmd As SqlCommand
    Private dr As SqlDataReader

    Public Sub New(ByVal SQLClause As String)
        dc = New Arena_DataConn.DataConnection
        cn$ConnName$ = New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
        cn$ConnName$.Open()
        cmd = New SqlCommand(SQLClause, cn$ConnName$)
        cmd.CommandType = CommandType.Text
        cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
        dr = cmd.ExecuteReader(CommandBehavior.SingleResult)
    End Sub

    Public Function ReadNext() As $ClassName$
        If dr.Read Then
            Dim Temp$ClassName$ As New $ClassName$
            $ClassName$.FillFields(Temp$ClassName$, dr)
            Return Temp$ClassName$
        End If
        Return Nothing
    End Function

#End Region

#Region " IDisposable Support "

    Private disposedValue As Boolean

    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not Me.disposedValue Then
            If disposing Then
                If cmd IsNot Nothing Then
                    cmd.Cancel()
                    cmd.Dispose()
                End If
                If dr IsNot Nothing Then dr.Close()
                If cn$ConnName$ IsNot Nothing Then cn$ConnName$.Close()
                If dc IsNot Nothing Then dc.Dispose()
            End If
        End If
        Me.disposedValue = True
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
        Dispose(True)
        GC.SuppressFinalize(Me)
    End Sub

#End Region

End Class
