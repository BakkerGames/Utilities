' $---$
' --- $Database$.$ClassName$ ---
' $---$

' --- This file is automatically generated. Please don't change! ---

Imports Arena_DataConn
Imports Arena_Utilities.StringUtils
Imports IDRIS_BaseLib
Imports System.Text
Imports System.Data.SqlClient

Public Class $ClassName$

    Inherits NonIDRISClass

#Region " Constants "

    Private Shared ReadOnly ObjName As String = System.Reflection.MethodBase.GetCurrentMethod().ReflectedType.FullName

    Private Shared _SQLTableName As String = "[$TableName$]"
    Private Shared _BaseQuery As String = $BaseQuery$
    Private Shared _FirstConj As String = $FirstConj$
    Private Shared _DeleteQuery As String = $DeleteQuery$

    Public Shared ReadOnly Property SQLTableName() As String
        Get
            FixSQLTablename()
            Return _SQLTableName
        End Get
    End Property
    Partial Private Shared Sub FixSQLTablename()
    End Sub

    Public Shared ReadOnly Property BaseQuery() As String
        Get
            FixBaseQuery()
            Return _BaseQuery
        End Get
    End Property
    Partial Private Shared Sub FixBaseQuery()
    End Sub

    Public Shared ReadOnly Property FirstConj() As String
        Get
            FixFirstConj()
            Return _FirstConj
        End Get
    End Property
    Partial Private Shared Sub FixFirstConj()
    End Sub

    Public Shared ReadOnly Property DeleteQuery() As String
        Get
            FixDeleteQuery()
            Return _DeleteQuery
        End Get
    End Property
    Partial Private Shared Sub FixDeleteQuery()
    End Sub

#End Region

$Properties$

#Region " Get Routines "

    Public Shared Function GetBySQL(ByVal SQLClause As String) As $ClassName$
        Dim Result As $ClassName$ = Nothing
        Dim dc As New Arena_DataConn.DataConnection
        Try
            Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
                cn$ConnName$.Open()
                Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        Result = New $ClassName$
                        $ClassName$.FillFields(Result, dr)
                    End If
                    dr.Close()
                End Using
            End Using
        Catch ex As Exception
            Throw ' re-throw the exception
        End Try
        Return Result
    End Function

    Public Shared Function GetAllBySQL(ByVal SQLClause As String) As List(Of $ClassName$)
        Dim Temp$ClassName$ As $ClassName$
        Dim Result As New List(Of $ClassName$)
        Dim dc As New Arena_DataConn.DataConnection
        Try
            Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
                cn$ConnName$.Open()
                Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleResult)
                    Do While dr.Read
                        Temp$ClassName$ = New $ClassName$
                        $ClassName$.FillFields(Temp$ClassName$, dr)
                        Result.Add(Temp$ClassName$)
                    Loop
                    dr.Close()
                End Using
            End Using
        Catch ex As Exception
            Throw ' re-throw the exception
        End Try
        Return Result
    End Function

#End Region

#Region " Internal Routines "

    Friend Overloads Shared Sub FillFields(ByVal Obj As $ClassName$, ByVal dr As SqlDataReader)
        If Obj Is Nothing Then Exit Sub
        If dr Is Nothing Then Exit Sub
        ' --- Prevent IsChanged = True while filling fields ---
        Obj.IsFillingFields = True
$FillFields$
        NonIDRISClass.FillFields(Obj, dr)
        ' --- Done filling fields ---
        Obj.IsFillingFields = False
        ' --- Fix record after filling if necessary ---
        FixRecordPostFill(Obj)
    End Sub

    Partial Private Shared Sub FixRecordPostFill(ByVal Obj As $ClassName$)
    End Sub

    Protected Overloads Shared Sub Validate(ByVal Obj As $ClassName$)
        If Obj Is Nothing Then Exit Sub
$ValidateList$
        NonIDRISClass.Validate(Obj)
    End Sub

    Protected Overloads Sub FieldList(ByVal sb As StringBuilder)
        ' --- used in the list of fields in an INSERT INTO command ---
        MyBase.FieldList(sb)
        With sb
$FieldList$
        End With
    End Sub

    Protected Overloads Sub ValueList(ByVal sb As StringBuilder)
        ' --- used in the list of values in an INSERT INTO command ---
        MyBase.ValueList(sb)
        With sb
$ValueList$
        End With
    End Sub

    Protected Overloads Sub UpdateList(ByVal sb As StringBuilder)
        ' --- used in the SET section of an UPDATE command ---
        MyBase.UpdateList(sb)
        With sb
$UpdateList$
        End With
    End Sub

#End Region

#Region " Clone Routine "

    Public Overloads Sub Clone(ByVal Obj As $ClassName$)
        If Obj Is Nothing Then Exit Sub
        ' --- Set internal values directly, for an exact copy ---
$CloneList$
        ' --- Now set all base class fields ---
        MyBase.Clone(Obj)
    End Sub

#End Region

#Region " Save Routine "

    Public Sub Save()
        Dim dc As New DataConnection
        $ClassName$.Save(Me, dc)
    End Sub

    Public Sub Save(ByVal dc As DataConnection)
        $ClassName$.Save(Me, dc)
    End Sub

    Public Shared Sub Save(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
        Static FuncName As String = ObjName + "." + System.Reflection.MethodBase.GetCurrentMethod().Name
        Dim sb As New StringBuilder
        Dim cn$ConnName$ As SqlConnection
        ' -------------------------------
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- delete record ---
        If Obj.IsDeleted Then
            $ClassName$.Delete(Obj, dc)
            Exit Sub
        End If
        Try
            ' --- fix record before saving if necessary ---
            FixRecordPreSave(Obj, dc)
            ' --- validate before saving ---
            $ClassName$.Validate(Obj)
            ValidateRecordLevel(Obj)
            ' --- add new record ---
            If Obj.IsNew OrElse Obj.$ID$.GetValueOrDefault <= 0 Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("INSERT INTO ")
                        .Append(SQLTableName)
                        .Append(" (")
                        Obj.FieldList(sb)
                        .Append(") VALUES (")
                        Obj.ValueList(sb)
                        .Append(") ; ")
                        ' --- Return the new record ---
                        .Append(BaseQuery)
                        .Append(FirstConj)
                        .Append(" [$ID$] = SCOPE_IDENTITY()")
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        NonIDRISClass.FillFields(Obj, dr) ' --- only fill base fields ---
                    Else
                        dc.Rollback()
                        Throw New SystemException("Record unexpectedly missing.")
                    End If
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- update changed record ---
            If Obj.IsChanged Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("UPDATE ")
                        .Append(SQLTableName)
                        .Append(" SET ")
                        Obj.UpdateList(sb)
                        .Append(" WHERE [$ID$] = ") : .Append(Obj.$ID$.Value.ToString)
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim RowsChanged As Integer = cmd.ExecuteNonQuery
                    If RowsChanged < 1 Then
                        dc.Rollback()
                        Throw New SystemException("Record unexpectedly missing or changed.")
                    End If
                    ' --- reload record to get updated values ---
                    cmd.CommandText = BaseQuery + FirstConj + " [$ID$] = " + Obj.$ID$.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        NonIDRISClass.FillFields(Obj, dr) ' --- only fill base fields ---
                    Else
                        dc.Rollback()
                        Throw New SystemException("Record unexpectedly missing.")
                    End If
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- fix record after saving if necessary ---
            FixRecordPostSave(Obj, dc)
        Catch ex As Exception
            dc.Rollback()
            Throw New SystemException(FuncName + vbCrLf + "Error saving record." + vbCrLf + ex.Message)
        End Try
    End Sub

    Partial Private Shared Sub FixRecordPreSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ValidateRecordLevel(ByVal Obj As $ClassName$)
    End Sub
    Partial Private Shared Sub FixRecordPostSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

#Region " Delete Routine "

    Public Sub Delete()
        Dim dc As New DataConnection
        $ClassName$.Delete(Me, dc)
    End Sub

    Public Sub Delete(ByVal dc As DataConnection)
        $ClassName$.Delete(Me, dc)
    End Sub

    Public Shared Sub Delete(ByRef Obj As $ClassName$, ByVal dc As DataConnection)
        Dim cn$ConnName$ As SqlConnection
        ' $---1---$
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- Release any resources before deleting if necessary ---
        ReleaseResourcesPreDelete(Obj, dc)
        ' --- Delete current record ---
        If Obj.$ID$.HasValue AndAlso Obj.$ID$.Value > 0 Then
            Try
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    cmd.CommandText = DeleteQuery + " WHERE [$ID$] = " + Obj.$ID$.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    cmd.ExecuteNonQuery()
                End Using
                dc.CloseConnection(cn$ConnName$)
            Catch ex As Exception
                dc.Rollback()
                Throw ' re-throw the exception
            End Try
        End If
        ' --- Release any resources after deleting if necessary ---
        ReleaseResourcesPostDelete(Obj, dc)
        ' --- Done ---
        Obj.$ID$ = Nothing
        Obj.IsDeleted = True
        Obj.IsNew = False
        Obj.IsChanged = False
    End Sub

    Partial Private Shared Sub ReleaseResourcesPreDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ReleaseResourcesPostDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

End Class

Public Class $ClassName$_Reader

    Implements IDisposable

#Region " Reader Routines "

    Private dc As Arena_DataConn.DataConnection
    Private cn$ConnName$ As SqlClient.SqlConnection
    Private cmd As SqlCommand
    Private dr As SqlDataReader

    Public Sub New(ByVal SQLClause As String)
        dc = New Arena_DataConn.DataConnection
        cn$ConnName$ = New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
        cn$ConnName$.Open()
        cmd = New SqlCommand(SQLClause, cn$ConnName$)
        cmd.CommandType = CommandType.Text
        cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
        dr = cmd.ExecuteReader(CommandBehavior.SingleResult)
    End Sub

    Public Function ReadNext() As $ClassName$
        If dr.Read Then
            Dim Temp$ClassName$ As New $ClassName$
            $ClassName$.FillFields(Temp$ClassName$, dr)
            Return Temp$ClassName$
        End If
        Return Nothing
    End Function

#End Region

#Region " IDisposable Support "

    Private disposedValue As Boolean

    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not Me.disposedValue Then
            If disposing Then
                If cmd IsNot Nothing Then
                    cmd.Cancel()
                    cmd.Dispose()
                End If
                If dr IsNot Nothing Then dr.Close()
                If cn$ConnName$ IsNot Nothing Then cn$ConnName$.Close()
                If dc IsNot Nothing Then dc.Dispose()
            End If
        End If
        Me.disposedValue = True
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
        Dispose(True)
        GC.SuppressFinalize(Me)
    End Sub

#End Region

End Class
