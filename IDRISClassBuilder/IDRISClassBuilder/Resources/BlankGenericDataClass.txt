' $---$
' --- $Database$.$ClassName$ ---
' $---$

' --- This file is automatically generated. Please don't change! ---

Imports System.Text
Imports IDRIS_BaseLib
Imports Arena_DataConn
Imports System.Data.SqlClient
Imports Arena_Utilities.StringUtils

Public Class $ClassName$

    Inherits CadolRecClass ' which inherits BaseClass

#Region " Constructors "

    Public Sub New()
        MyBase.New()
    End Sub

    Public Sub New(ByVal Layout As String)
        MyBase.New(Layout)
    End Sub

#End Region

#Region " Constants "

    Private Shared ReadOnly ObjName As String = System.Reflection.MethodBase.GetCurrentMethod().ReflectedType.FullName

    Private Shared _SQLTableName As String = "[$TableName$]"
    Private Shared _BaseQuery As String = $BaseQuery$
    Private Shared _FirstConj As String = $FirstConj$
    Private Shared _DeleteQuery As String = $DeleteQuery$

    Public Shared ReadOnly Property SQLTableName() As String
        Get
            FixSQLTablename()
            Return _SQLTableName
        End Get
    End Property
    Partial Private Shared Sub FixSQLTablename()
    End Sub

    Public Shared ReadOnly Property BaseQuery() As String
        Get
            FixBaseQuery()
            Return _BaseQuery
        End Get
    End Property
    Partial Private Shared Sub FixBaseQuery()
    End Sub

    Public Shared ReadOnly Property FirstConj() As String
        Get
            FixFirstConj()
            Return _FirstConj
        End Get
    End Property
    Partial Private Shared Sub FixFirstConj()
    End Sub

    Public Shared ReadOnly Property DeleteQuery() As String
        Get
            FixDeleteQuery()
            Return _DeleteQuery
        End Get
    End Property
    Partial Private Shared Sub FixDeleteQuery()
    End Sub

#End Region

#Region " Get Routines "

    Public Shared Function GetByRec(ByVal Rec As Integer) As $ClassName$
        Return $ClassName$.GetBySQL(BaseQuery + FirstConj + " [REC] = " + Rec.ToString)
    End Function

    Public Shared Function GetByKey(ByVal Key As String) As $ClassName$
        Return $ClassName$.GetBySQL(BaseQuery + FirstConj + " [KEY] = '" + StringToSQL(Key) + "'")
    End Function

    Public Shared Function GetByKeyVolume(ByVal Key As String, ByVal Volume As String) As $ClassName$
        Return $ClassName$.GetBySQL(BaseQuery + _
$Class_Spc$                         FirstConj + " [KEY] = '" + StringToSQL(Key) + "'" + _
$Class_Spc$                         " AND [VOLUME] = '" + StringToSQL(Volume) + "'")
    End Function

    Public Shared Function GetByKeyVolumeRecType(ByVal Key As String, ByVal Volume As String, ByVal RecType As Byte) As $ClassName$
        Return $ClassName$.GetBySQL(BaseQuery + _
$Class_Spc$                         FirstConj + " [KEY] = '" + StringToSQL(Key) + "'" + _
$Class_Spc$                         " AND [VOLUME] = '" + StringToSQL(Volume) + "'" + _
$Class_Spc$                         " AND SUBSTRING([PACKED_DATA],1,1) = 0x" + Right("00" + Hex(RecType), 2))
    End Function

    Public Shared Function GetNextByRec(ByVal LastRec As Integer) As $ClassName$
        ' --- Send zero the first time, and the returned Rec each subsequent time ---
        Return $ClassName$.GetBySQL(BaseQuery.Replace("SELECT ", "SELECT TOP 1 ") + FirstConj + " [REC] > " + LastRec.ToString + " ORDER BY [REC] ASC")
    End Function

    Public Shared Function GetBySQL(ByVal SQLClause As String) As $ClassName$
        Dim Result As $ClassName$ = Nothing
        Dim dc As New Arena_DataConn.DataConnection
        Try
            Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
                cn$ConnName$.Open()
                Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        Result = New $ClassName$
                        $ClassName$.FillFields(Result, dr)
                    End If
                    dr.Close()
                End Using
            End Using
        Catch ex As Exception
            Throw ' re-throw the exception
        End Try
        Return Result
    End Function

    Public Shared Function GetAll() As List(Of $ClassName$)
        Return $ClassName$.GetAllBySQL(BaseQuery + " ORDER BY [REC]")
    End Function

    Public Shared Function GetAllByKey(ByVal Key As String) As List(Of $ClassName$)
        Return $ClassName$.GetAllBySQL(BaseQuery + _
$Class_Spc$                            FirstConj + " [KEY] = '" + StringToSQL(Key) + "'" + _
$Class_Spc$                            " ORDER BY [REC]")
    End Function

    Public Shared Function GetAllByKeyVolume(ByVal Key As String, ByVal Volume As String) As List(Of $ClassName$)
        Return $ClassName$.GetAllBySQL(BaseQuery + _
$Class_Spc$                            FirstConj + " [KEY] = '" + StringToSQL(Key) + "'" + _
$Class_Spc$                            " AND [VOLUME] = '" + StringToSQL(Volume) + "'" + _
$Class_Spc$                            " ORDER BY [REC]")
    End Function

    Public Shared Function GetAllByKeyVolumeRecType(ByVal Key As String, ByVal Volume As String, ByVal RecType As Byte) As List(Of $ClassName$)
        Return $ClassName$.GetAllBySQL(BaseQuery + _
$Class_Spc$                            FirstConj + " [KEY] = '" + StringToSQL(Key) + "'" + _
$Class_Spc$                            " AND [VOLUME] = '" + StringToSQL(Volume) + "'" + _
$Class_Spc$                            " AND SUBSTRING([PACKED_DATA],1,1) = 0x" + Right("00" + Hex(RecType), 2) + _
$Class_Spc$                            " ORDER BY [REC]")
    End Function

    Public Shared Function GetAllBySQL(ByVal SQLClause As String) As List(Of $ClassName$)
        Dim Temp$ClassName$ As $ClassName$
        Dim Result As New List(Of $ClassName$)
        Dim dc As New Arena_DataConn.DataConnection
        Try
            Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
                cn$ConnName$.Open()
                Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleResult)
                    Do While dr.Read
                        Temp$ClassName$ = New $ClassName$
                        $ClassName$.FillFields(Temp$ClassName$, dr)
                        Result.Add(Temp$ClassName$)
                    Loop
                    dr.Close()
                End Using
            End Using
        Catch ex As Exception
            Throw ' re-throw the exception
        End Try
        Return Result
    End Function

#End Region

#Region " Internal Routines "

    Friend Overloads Shared Sub FillFields(ByVal Obj As $ClassName$, ByVal dr As SqlDataReader)
        If Obj Is Nothing Then Exit Sub
        If dr Is Nothing Then Exit Sub
        CadolRecClass.FillFields(Obj, dr)
    End Sub

    Protected Overloads Shared Sub Validate(ByVal Obj As $ClassName$)
        If Obj Is Nothing Then Exit Sub
        CadolRecClass.Validate(Obj)
    End Sub

    Protected Overloads Sub FieldList(ByVal sb As StringBuilder)
        ' --- used in the list of fields in an INSERT INTO command ---
        MyBase.FieldList(sb)
    End Sub

    Protected Overloads Sub ValueList(ByVal sb As StringBuilder)
        ' --- used in the list of values in an INSERT INTO command ---
        MyBase.ValueList(sb)
    End Sub

    Protected Overloads Sub UpdateList(ByVal sb As StringBuilder)
        ' --- used in the SET section of an UPDATE command ---
        MyBase.UpdateList(sb)
    End Sub

#End Region

#Region " Clone Routine "

    Public Overloads Sub Clone(ByVal Obj As $ClassName$)
        If Obj Is Nothing Then Exit Sub
        ' --- This object has no new properties ---
        ' --- Now set all base class fields ---
        MyBase.Clone(Obj)
    End Sub

#End Region

#Region " Save Routine "

    Public Sub Save()
        Dim dc As New DataConnection
        $ClassName$.Save(Me, dc)
    End Sub

    Public Sub Save(ByVal dc As DataConnection)
        $ClassName$.Save(Me, dc)
    End Sub

    Public Shared Sub Save(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
        Static FuncName As String = ObjName + "." + System.Reflection.MethodBase.GetCurrentMethod().Name
        Dim sb As New StringBuilder
        Dim cn$ConnName$ As SqlConnection
        ' -------------------------------
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- delete record ---
        If Obj.IsDeleted Then
            $ClassName$.Delete(Obj, dc)
            Exit Sub
        End If
        Try
            ' --- fix record before saving if necessary ---
            FixRecordPreSave(Obj, dc)
            ' --- validate before saving ---
            $ClassName$.Validate(Obj)
            ValidateRecordLevel(Obj)
            ' --- add new record ---
            If Obj.IsNew OrElse Obj.REC.GetValueOrDefault <= 0 Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("INSERT INTO ")
                        .Append(SQLTableName)
                        .Append(" (")
                        Obj.FieldList(sb)
                        .Append(") VALUES (")
                        Obj.ValueList(sb)
                        .Append(") ; ")
                        ' --- Return the new record ---
                        .Append(BaseQuery)
                        .Append(FirstConj)
                        .Append(" [REC] = SCOPE_IDENTITY()")
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        CadolRecClass.FillFields(Obj, dr) ' --- only fill base fields ---
                    Else
                        dc.Rollback()
                        Throw New SystemException(Obj.RecordMissingErrorMsg())
                    End If
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- update changed record ---
            If Obj.IsChanged Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("UPDATE ")
                        .Append(SQLTableName)
                        .Append(" SET ")
                        Obj.UpdateList(sb)
                        .Append(" WHERE [REC] = ") : .Append(Obj.REC.Value.ToString)
                        .Append(" AND [RowVersion] = ") : .Append(Obj.RowVersion_ToSQL)
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim RowsChanged As Integer = cmd.ExecuteNonQuery
                    If RowsChanged < 1 Then
                        dc.Rollback()
                        Throw New SystemException(Obj.RecordMissingOrChangedErrorMsg())
                    End If
                    ' --- reload record to get updated values (such as RowVersion) ---
                    cmd.CommandText = BaseQuery + FirstConj + " [REC] = " + Obj.REC.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        BaseClass.FillFields(Obj, dr) ' --- only fill base fields ---
                    Else
                        dc.Rollback()
                        Throw New SystemException(Obj.RecordMissingErrorMsg())
                    End If
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- fix record after saving if necessary ---
            FixRecordPostSave(Obj, dc)
        Catch ex As Exception
            dc.Rollback()
            Throw New SystemException(FuncName + vbCrLf + "Error saving record." + vbCrLf + ex.Message)
        End Try
    End Sub

    Partial Private Shared Sub FixRecordPreSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ValidateRecordLevel(ByVal Obj As $ClassName$)
    End Sub
    Partial Private Shared Sub FixRecordPostSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

#Region " Delete Routine "

    Public Sub Delete()
        Dim dc As New DataConnection
        $ClassName$.Delete(Me, dc)
    End Sub

    Public Sub Delete(ByVal dc As DataConnection)
        $ClassName$.Delete(Me, dc)
    End Sub

    Public Shared Sub Delete(ByRef Obj As $ClassName$, ByVal dc As DataConnection)
        Dim cn$ConnName$ As SqlConnection
        ' $---1---$
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- Release any resources before deleting if necessary ---
        ReleaseResourcesPreDelete(Obj, dc)
        ' --- Delete current record ---
        If Obj.REC.HasValue AndAlso Obj.REC.Value > 0 Then
            Try
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    cmd.CommandText = DeleteQuery + " WHERE [REC] = " + Obj.REC.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    cmd.ExecuteNonQuery()
                End Using
                dc.CloseConnection(cn$ConnName$)
            Catch ex As Exception
                dc.Rollback()
                Throw ' re-throw the exception
            End Try
        End If
        ' --- Release any resources after deleting if necessary ---
        ReleaseResourcesPostDelete(Obj, dc)
        ' --- Done ---
        Obj.REC = Nothing
        Obj.IsDeleted = True
        Obj.IsNew = False
        Obj.IsChanged = False
    End Sub

    Partial Private Shared Sub ReleaseResourcesPreDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ReleaseResourcesPostDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

End Class
