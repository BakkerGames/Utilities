' $---$
' --- $Database$.$SchemaName$$ClassShort$ ---
' $---$

' --- This file is automatically generated. Please don't change! ---

Imports Arena_BaseLib
Imports Arena_DataConn
Imports Arena_Utilities.DateUtils
Imports Arena_Utilities.StringUtils
Imports System.Data.SqlClient
Imports System.Text

Public Class $ClassName$

    Inherits $BaseClass$

#Region " Constants "

    Private Shared ReadOnly ObjName As String = System.Reflection.MethodBase.GetCurrentMethod().ReflectedType.FullName

    Private Shared$Shadows$ _SQLTableName As String = "$SchemaFull$[$ClassShort$]"
    Private Shared$Shadows$ _BaseQuery As String = $BaseQuery$
    Private Shared$Shadows$ _FirstConj As String = $FirstConj$
    Private Shared$Shadows$ _DeleteQuery As String = $DeleteQuery$

    Public Shared$Shadows$ ReadOnly Property SQLTableName() As String
        Get
            FixSQLTablename()
            Return _SQLTableName
        End Get
    End Property
    Partial Private Shared Sub FixSQLTablename()
    End Sub

    Public Shared$Shadows$ ReadOnly Property BaseQuery() As String
        Get
            FixBaseQuery()
            Return _BaseQuery
        End Get
    End Property
    Partial Private Shared Sub FixBaseQuery()
    End Sub

    Public Shared$Shadows$ ReadOnly Property FirstConj() As String
        Get
            FixFirstConj()
            Return _FirstConj
        End Get
    End Property
    Partial Private Shared Sub FixFirstConj()
    End Sub

    Public Shared$Shadows$ ReadOnly Property DeleteQuery() As String
        Get
            FixDeleteQuery()
            Return _DeleteQuery
        End Get
    End Property
    Partial Private Shared Sub FixDeleteQuery()
    End Sub

#End Region

$Properties$

#Region " Get Routines "

    Public Shared$Shadows$ Function GetByID(ByVal ID As Integer) As $ClassName$
        Return $ClassName$.GetBySQL(BaseQuery + FirstConj + " [ID] = " + ID.ToString)
    End Function

    Public Shared$Shadows$ Function GetNextByID(ByVal LastID As Integer) As $ClassName$
        ' --- Send zero the first time, and the returned ID each subsequent time ---
        Return $ClassName$.GetBySQL(BaseQuery.Replace("SELECT ", "SELECT TOP 1 ") + FirstConj + " [ID] > " + LastID.ToString + " ORDER BY [ID] ASC")
    End Function

    Public Shared$Shadows$ Function GetBySQL(ByVal SQLClause As String) As $ClassName$
        Dim Result As $ClassName$ = Nothing
        Dim dc As New Arena_DataConn.DataConnection
        Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
            cn$ConnName$.Open()
            Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                cmd.CommandType = CommandType.Text
                cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                If dr.Read Then
                    Result = New $ClassName$
                    $ClassName$.FillFields(Result, dr)
                End If
                dr.Close()
            End Using
        End Using
        Return Result
    End Function

    Public Shared$Shadows$ Function GetAll() As List(Of $ClassName$)
        Return $ClassName$.GetAllBySQL(BaseQuery + " ORDER BY [ID]")
    End Function

    Public Shared$Shadows$ Function GetAllBySQL(ByVal SQLClause As String) As List(Of $ClassName$)
        Dim Temp$ClassName$ As $ClassName$
        Dim Result As New List(Of $ClassName$)
        Dim dc As New Arena_DataConn.DataConnection
        Using cn$ConnName$ As New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
            cn$ConnName$.Open()
            Using cmd As New SqlCommand(SQLClause, cn$ConnName$)
                cmd.CommandType = CommandType.Text
                cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleResult)
                Do While dr.Read
                    Temp$ClassName$ = New $ClassName$
                    $ClassName$.FillFields(Temp$ClassName$, dr)
                    Result.Add(Temp$ClassName$)
                Loop
                dr.Close()
            End Using
        End Using
        Return Result
    End Function

#End Region

#Region " Internal Routines "

    Friend Overloads Shared Sub FillFields(ByVal Obj As $ClassName$, ByVal dr As SqlDataReader)
        If Obj Is Nothing Then Exit Sub
        If dr Is Nothing Then Exit Sub
        ' --- Prevent IsChanged = True while filling fields ---
        Obj.IsFillingFields = True
$FillFields$
        $BaseClass$.FillFields(Obj, dr)
        ' --- Done filling fields ---
        Obj.IsFillingFields = False
        ' --- Fix record after filling if necessary ---
        FixRecordPostFill(Obj)
    End Sub

    Partial Private Shared Sub FixRecordPostFill(ByVal Obj As $ClassName$)
    End Sub

    Protected Overloads Shared Sub Validate(ByVal Obj As $ClassName$)
        If Obj Is Nothing Then Exit Sub
$ValidateList$
        $BaseClass$.Validate(Obj)
    End Sub

    Protected Overloads Sub FieldList(ByVal sb As StringBuilder)
        ' --- used in the list of fields in an INSERT INTO command ---
        MyBase.FieldList(sb)
        With sb
$FieldList$
        End With
    End Sub

    Protected Overloads Sub ValueList(ByVal sb As StringBuilder)
        ' --- used in the list of values in an INSERT INTO command ---
        MyBase.ValueList(sb)
        With sb
$ValueList$
        End With
    End Sub

    Protected Overloads Sub UpdateList(ByVal sb As StringBuilder)
        ' --- used in the SET section of an UPDATE command ---
        MyBase.UpdateList(sb)
        With sb
$UpdateList$
        End With
    End Sub

#End Region

#Region " Clone Routine "

    ''' <summary>
    ''' Clones "Me" into the parameter object. Creates one if Nothing. Doesn't clone ID fields so it's a separate record.
    ''' </summary>
    Public Overloads Sub Clone(ByRef Obj As $ClassName$)
        If Obj Is Nothing Then Obj = New $ClassName$
        ' --- Set internal values directly ---
$CloneList$
        ' --- Set base class fields, except for ID fields ---
        MyBase.Clone(Obj)
        ' --- Also clone sub records, if any ---
        CloneSubRecords(Obj)
    End Sub

    Partial Private Sub CloneSubRecords(ByRef Obj As $ClassName$)
    End Sub

#End Region

#Region " Save Routine "

    Public$Shadows$ Sub Save()
        Dim dc As New DataConnection
        $ClassName$.Save(Me, dc)
    End Sub

    Public$Shadows$ Sub Save(ByVal dc As DataConnection)
        $ClassName$.Save(Me, dc)
    End Sub

    Public Shared$Shadows$ Sub Save(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
        Static FuncName As String = ObjName + "." + System.Reflection.MethodBase.GetCurrentMethod().Name
        Dim sb As New StringBuilder
        Dim cn$ConnName$ As SqlConnection
        ' $---1---$
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- delete record ---
        If Obj.IsDeleted Then
            $ClassName$.Delete(Obj, dc)
            Exit Sub
        End If
        Try
            ' --- fix record before saving if necessary ---
            FixRecordPreSave(Obj, dc)
            ' --- validate before saving ---
            $ClassName$.Validate(Obj)
            ValidateRecordLevel(Obj)
            ' --- add new record ---
            If Obj.IsNew OrElse Obj.ID.GetValueOrDefault <= 0 Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("INSERT INTO ")
                        .Append(SQLTableName)
                        .Append(" (")
                        Obj.FieldList(sb)
                        .Append(") VALUES (")
                        Obj.ValueList(sb)
                        .Append(") ; ")
                        ' --- Return the new record ---
                        .Append(BaseQuery)
                        .Append(FirstConj)
                        .Append(" [ID] = SCOPE_IDENTITY()")
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    ' --- Retry several times if a SQLException occurs ---
                    Dim RetryCount As Integer = 0
                    Dim dr As SqlDataReader = Nothing
                    Do
                        Try
                            dr = cmd.ExecuteReader(CommandBehavior.SingleRow)
                            If Not dr.Read Then
                                dc.Rollback()
                                Throw New SystemException(Obj.RecordMissingErrorMsg())
                            End If
                        Catch ex As SqlException
                            RetryCount += 1
                            If RetryCount >= DataConnection.MaxSQLRetryCount Then
                                dc.Rollback()
                                Throw New SystemException(Obj.SQLTimeoutErrorMsg(ex.Message))
                            End If
                        Catch ex As Exception
                            dc.Rollback()
                            Throw New SystemException(ex.Message)
                        End Try
                    Loop Until dr IsNot Nothing
                    BaseClass.FillFields(Obj, dr) ' --- only fill base fields ---
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- update changed record ---
            If Obj.IsChanged Then
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    With sb
                        .Append("UPDATE ")
                        .Append(SQLTableName)
                        .Append(" SET ")
                        Obj.UpdateList(sb)
                        .Append(" WHERE [ID] = ") : .Append(Obj.ID.Value.ToString)
                        .Append(" AND [RowVersion] = ") : .Append(Obj.RowVersion_ToSQL)
                    End With
                    cmd.CommandText = sb.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    ' --- Retry several times if a SQLException occurs ---
                    Dim RetryCount As Integer = 0
                    Dim RowsChanged As Integer = 0
                    Do
                        Try
                            RowsChanged = cmd.ExecuteNonQuery
                            If RowsChanged = 0 Then
                                dc.Rollback()
                                Throw New SystemException(Obj.RecordMissingOrChangedErrorMsg(RowsChanged))
                            End If
                        Catch ex As SqlException
                            RetryCount += 1
                            If RetryCount >= DataConnection.MaxSQLRetryCount Then
                                dc.Rollback()
                                Throw New SystemException(Obj.SQLTimeoutErrorMsg(ex.Message))
                            End If
                        Catch ex As Exception
                            dc.Rollback()
                            Throw New SystemException(ex.Message)
                        End Try
                    Loop Until RowsChanged <> 0
                    ' --- reload record to get updated values (such as RowVersion) ---
                    cmd.CommandText = BaseQuery + FirstConj + " [ID] = " + Obj.ID.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    Dim dr As SqlDataReader = cmd.ExecuteReader(CommandBehavior.SingleRow)
                    If dr.Read Then
                        BaseClass.FillFields(Obj, dr) ' --- only fill base fields ---
                    Else
                        dc.Rollback()
                        Throw New SystemException(Obj.RecordMissingErrorMsg())
                    End If
                    dr.Close()
                    dc.CloseConnection(cn$ConnName$)
                End Using
                Obj.IsChanged = False
            End If
            ' --- fix record after saving if necessary ---
            FixRecordPostSave(Obj, dc)
        Catch ex As Exception
            dc.Rollback()
            Throw New SystemException($"{FuncName}{vbCrLf}Error saving record:{vbCrLf}{ex.Message}")
        End Try
    End Sub

    Partial Private Shared Sub FixRecordPreSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ValidateRecordLevel(ByVal Obj As $ClassName$)
    End Sub
    Partial Private Shared Sub FixRecordPostSave(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

#Region " Delete Routine "

    Public$Shadows$ Sub Delete()
        Dim dc As New DataConnection
        $ClassName$.Delete(Me, dc)
    End Sub

    Public$Shadows$ Sub Delete(ByVal dc As DataConnection)
        $ClassName$.Delete(Me, dc)
    End Sub

    Public Shared$Shadows$ Sub Delete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
        Static FuncName As String = ObjName + "." + System.Reflection.MethodBase.GetCurrentMethod().Name
        Dim cn$ConnName$ As SqlConnection
        ' $---1---$
        If Obj Is Nothing Then Exit Sub
        If dc Is Nothing Then Exit Sub
        ' --- Validate if record may be safely deleted ---
        ValidatePreDelete(Obj, dc)
        ' --- Release any resources before deleting if necessary ---
        ReleaseResourcesPreDelete(Obj, dc)
        ' --- Delete current record ---
        If Obj.ID.HasValue AndAlso Obj.ID.Value > 0 Then
            Try
                cn$ConnName$ = dc.GetConnection_$ConnName$
                Using cmd As SqlCommand = cn$ConnName$.CreateCommand
                    cmd.Transaction = dc.GetTransaction_$ConnName$
                    cmd.CommandText = DeleteQuery + " WHERE [ID] = " + Obj.ID.Value.ToString
                    cmd.CommandType = CommandType.Text
                    cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
                    cmd.ExecuteNonQuery()
                End Using
                dc.CloseConnection(cn$ConnName$)
            Catch ex As Exception
                dc.Rollback()
                Throw New SystemException($"{FuncName}{vbCrLf}Error deleting record:{vbCrLf}{ex.Message}")
            End Try
        End If
        ' --- Release any resources after deleting if necessary ---
        ReleaseResourcesPostDelete(Obj, dc)
        ' --- Done ---
        Obj.ID = Nothing
        Obj.IsDeleted = True
        Obj.IsNew = False
        Obj.IsChanged = False
    End Sub

    Partial Private Shared Sub ValidatePreDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ReleaseResourcesPreDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub
    Partial Private Shared Sub ReleaseResourcesPostDelete(ByVal Obj As $ClassName$, ByVal dc As DataConnection)
    End Sub

#End Region

End Class

Public Class $ClassName$_Reader

    Implements IDisposable

#Region " Reader Routines "

    Private dc As Arena_DataConn.DataConnection
    Private cn$ConnName$ As SqlClient.SqlConnection
    Private cmd As SqlCommand
    Private dr As SqlDataReader

    Public Sub New(ByVal SQLClause As String)
        dc = New Arena_DataConn.DataConnection
        cn$ConnName$ = New SqlClient.SqlConnection(dc.ConnectionString_$ConnName$)
        cn$ConnName$.Open()
        cmd = New SqlCommand(SQLClause, cn$ConnName$)
        cmd.CommandType = CommandType.Text
        cmd.CommandTimeout = DataConnection.SQLTimeoutSeconds
        dr = cmd.ExecuteReader(CommandBehavior.SingleResult)
    End Sub

    Public Function ReadNext() As $ClassName$
        If dr.Read Then
            Dim Temp$ClassName$ As New $ClassName$
            $ClassName$.FillFields(Temp$ClassName$, dr)
            Return Temp$ClassName$
        End If
        Return Nothing
    End Function

#End Region

#Region " IDisposable Support "

    Private disposedValue As Boolean

    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not Me.disposedValue Then
            If disposing Then
                If cmd IsNot Nothing Then
                    cmd.Cancel()
                    cmd.Dispose()
                End If
                If dr IsNot Nothing Then dr.Close()
                If cn$ConnName$ IsNot Nothing Then cn$ConnName$.Close()
                If dc IsNot Nothing Then dc.Dispose()
            End If
        End If
        Me.disposedValue = True
    End Sub

    Public Sub Dispose() Implements IDisposable.Dispose
        Dispose(True)
        GC.SuppressFinalize(Me)
    End Sub

#End Region

End Class
